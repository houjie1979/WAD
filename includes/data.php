<?php// If it's going to need the database, then it's // probably smart to require it before we start.require_once(LIB_PATH.DS.'database.php');class Data extends DatabaseObject {		protected static $table_name = "data";	protected static $db_fields = array('id', 'refcode', 'isocode', 'source', 'absorber',	'stemp', 'atemp', 'ishift', 'qsplit', 'ecomments', 'keywords');		public $id;	public $refcode;	public $isocode;	public $source;	public $absorber;	public $stemp;	public $atemp;	public $ishift;	public $qsplit;	public $ecomments;	public $keywords;					public function record_exists(){	  	global $database;		$select_sql = "SELECT COUNT(*) FROM data WHERE refcode = '{$this->refcode}' ";		$select_sql .= " AND isocode = '{$this->isocode}' ";		$select_sql .= " AND absorber = '{$this->absorber}' ";		$select_sql .= " AND atemp = '{$this->atemp}' ";		$select_sql .= " AND ishift = '{$this->ishift}' ";		$select_sql .= " AND qsplit = '{$this->qsplit}' ";		$select_sql .= " AND ecomments = '{$this->ecomments}' ";		$select_sql .= " AND source = '{$this->source}' ";		$select_sql .= " AND stemp = '{$this->stemp}' ";		$result_set = $database->query($select_sql);		$rows = array_shift($database->fetch_array($result_set));		if(!empty($rows)) {	return true; } else return false;	}	  public function code_name() {    if(isset($this->id) && isset($this->refcode)) {	      return $this->refcode . " " . $this->isocode . " " . $this->source . " " .	  		$this->absorber . " " . $this->stemp . " " . $this->atemp . " " .			$this->ishift . " " . $this->qsplit . " " . htmlentities($this->ecomments) . " " .			$this->keywords;    } else {      return "";    }  }  	public function data_search($refcode, $year){	// not used ?		$sql = "SELECT * FROM data ";		if($refcode !="") $sql .=" WHERE refcode= '{$refcode}'";		return self::find_by_sql($sql);		}public static function data_sql_where($refcode, $isocode, $source, $absorber, 			$stemp, $atemp, $ishift, $qsplit, $ecomments, $keywords){				$sql = "";		if($refcode !="") {$sql .=" AND refcode= '{$refcode}' "; }		if($isocode !="") {$sql .=" AND isocode= '{$isocode}' "; }		if($source !="")  {$sql .=" AND  LOCATE('{$source}', source) ";	}		if($absorber !=""){$sql .=" AND LOCATE('{$absorber}', absorber) ";}		if($stemp !=""){			$nstemp =  array(250,350);			$nstemp = self::parse_pair($stemp);			$sql .=" AND stemp >= '{$nstemp[0]}' AND stemp <= '{$nstemp[1]}' ";		}		if($atemp !=""){			$natemp = self::parse_pair($atemp);			$sql .=" AND atemp >= '{$natemp[0]}' AND atemp <= '{$natemp[1]}' ";		}		if($ishift !=""){			$nishift = self::parse_pair($ishift);			$sql .=" AND ishift >= '{$nishift[0]}' AND ishift <= '{$nishift[1]}' ";		}		if($qsplit !=""){			$nqsplit = self::parse_pair($qsplit);			$sql .=" AND qsplit >= '{$nqsplit[0]}' AND qsplit <= '{$nqsplit[1]}' ";		}		if($ecomments !=""){			$sql .=" AND  LOCATE( '{$ecomments}', ecomments) ";					}		if($keywords !=""){			$keycodes = self::parse_keys($keywords);			foreach($keycodes as $keyword) $sql .=" AND LOCATE('{$keyword}', keywords) ";		}	return $sql;	}public function createdatarecord() {		global $database;		$database->close_connection();		$database->open_admin_connection();		$query = "INSERT INTO data            ( refcode, isocode, source, absorber, stemp, atemp, ishift, qsplit, ecomments, keywords)            VALUES ('{$this->refcode}',					'{$this->isocode}', 					'{$this->source}',					'{$this->absorber}',";		if($this->stemp == "") $query.= "NULL,"; 		else $query .= "'{$this->stemp}',";		if($this->atemp == "") $query .= "NULL,"; 		else $query .= "'{$this->atemp}',";		if($this->ishift == "") $query .= "NULL,";		else $query = $query . "'{$this->ishift}',";		if($this->qsplit == "") $query .= "NULL,";		 else $query .= "'{$this->qsplit}',";		$query .= " '{$this->ecomments} ', '{$this->keywords} ' )";	  	if($database->query($query)) {	    	$this->id = $database->insert_id();	   	 return true;	  	} else {	    	return false;	  	}	}		// Common Database Methods		public static function parse_keys($string) {		$string = trim($string);		if(strstr($string," ")) {//multiple keyword seprated by blank			$keys = explode(" ",$string);		}else{//add by jiehou 2018-06-14 (single keyword without any blank)			$keys=array($string);		}		return $keys;	}		public static function parse_pair($string) {		$string = trim($string);		$pair = explode(" ",$string);		if(count($pair) == 1) { // generate range value			$pair[1] = 0.01*abs($pair[0]);			$pair[0] -=$pair[1];			$pair[1] = $pair[0] + 2*$pair[1];		}		else {	// two values			if( ($pair[0] > 0) && ($pair[0] > $pair[1]) ) { // range case				$pair[0] -= $pair[1];				$pair[1] = $pair[0] + 2*$pair[1];			}		else{  }// ll-ul case		}							return $pair;  }  		public static function find_all() {		return self::find_by_sql("SELECT * FROM ".self::$table_name. " ORDER BY ".self::$db_fields[0] );  }    public static function find_by_id($id=0) {    $result_array = self::find_by_sql("SELECT * FROM ".self::$table_name." WHERE id={$id} LIMIT 1");		return !empty($result_array) ? array_shift($result_array) : false;  }    public static function find_by_sql($sql="") {    global $database;    $result_set = $database->query($sql);    $object_array = array();    while ($row = $database->fetch_array($result_set)) {      $object_array[] = self::instantiate($row);    }    return $object_array;  }   public static function find_by_sql_lim($sql, $limit, $offset){		// commonized			if(!empty($sql)) {		$select_sql = "SELECT * FROM " . self::$table_name . " WHERE 1 " . $sql;		$select_sql .= " ORDER BY ishift DESC, qsplit DESC ";		$select_sql .= " LIMIT {$limit} ";			$select_sql .= " OFFSET {$offset}";		return self::find_by_sql($select_sql);		}		else return NULL;	}     public static function count_all(){  	global $database;	$sql = "SELECT COUNT(*) FROM ".self::$table_name;	$result_set = $database->query($sql);	$row = $database->fetch_array($result_set);	return array_shift($row);	}  public static function count_in_sql($sql){	// commonized  	global $database;	$select_sql = "SELECT COUNT(*) FROM ".self::$table_name;	if(!empty($sql)){		$select_sql .= " WHERE 1 " . $sql;		$result_set = $database->query($select_sql);		$row = $database->fetch_array($result_set);		return array_shift($row);	}	else return 0;}	private static function instantiate($record) {		// Could check that $record exists and is an array    $object = new self;		// Simple, long-form approach:		// $object->id 				= $record['id'];		// $object->username 	= $record['username'];		// $object->password 	= $record['password'];		// $object->first_name = $record['first_name'];		// $object->last_name 	= $record['last_name'];				// More dynamic, short-form approach:		foreach($record as $attribute=>$value){		  if($object->has_attribute($attribute)) {		    $object->$attribute = $value;		  }		}		return $object;	}	public static function instantiateit($record) {		// Could check that $record exists and is an array    $object = new self;		// Simple, long-form approach:		// $object->id 				= $record['id'];		// $object->username 	= $record['username'];		// $object->password 	= $record['password'];		// $object->first_name = $record['first_name'];		// $object->last_name 	= $record['last_name'];				// More dynamic, short-form approach:		foreach($record as $attribute=>$value){		  if($object->has_attribute($attribute)) {		    $object->$attribute = $value;		  }		}		return $object;	}			private function has_attribute($attribute) {	  // We don't care about the value, we just want to know if the key exists	  // Will return true or false	  return array_key_exists($attribute, $this->attributes());	}	protected function attributes() { 		// return an array of attribute names and their values	  $attributes = array();	  foreach(self::$db_fields as $field) {	    if(property_exists($this, $field)) {	      $attributes[$field] = $this->$field;	    }	  }	  return $attributes;	}		public function sanitized_attributes() {	// or protected?	  global $database;	  $clean_attributes = array();	  // sanitize the values before submitting	  // Note: does not alter the actual value of each attribute	  foreach($this->attributes() as $key => $value){		if($value != NULL)	    $clean_attributes[$key] = $database->escape_value($value);	  }	  return $clean_attributes;	}		public function save() {	  // A new record won't have an id yet.	  return isset($this->id) ? $this->update() : $this->create();	}		public function create() {		global $database;		$database->close_connection();		$database->open_admin_connection();		// Don't forget your SQL syntax and good habits:		// - INSERT INTO table (key, key) VALUES ('value', 'value')		// - single-quotes around all values		// - escape all values to prevent SQL injection		$attributes = $this->sanitized_attributes();	  $sql = "INSERT INTO ".self::$table_name." (";		$sql .= join(", ", array_keys($attributes));	  $sql .= ") VALUES ('";		$sql .= join("', '", array_values($attributes));		$sql .= "') ";	  if($database->query($sql)) {	    $this->id = $database->insert_id();	    return true;	  } else {	    return false;	  }	}	public function update() {	  global $database;	  	$database->close_connection();		$database->open_admin_connection();		// Don't forget your SQL syntax and good habits:		// - UPDATE table SET key='value', key='value' WHERE condition		// - single-quotes around all values		// - escape all values to prevent SQL injection		$attributes = $this->sanitized_attributes();		$attribute_pairs = array();		foreach($attributes as $key => $value) {		  $attribute_pairs[] = "{$key}='{$value}'";		}		$sql = "UPDATE ".self::$table_name." SET ";		$sql .= join(", ", $attribute_pairs);		$sql .= " WHERE id=". $database->escape_value($this->id);	  $database->query($sql);	  return ($database->affected_rows() == 1) ? true : false;	}	public function delete() {		global $database;		// Don't forget your SQL syntax and good habits:		// - DELETE FROM table WHERE condition LIMIT 1		// - escape all values to prevent SQL injection		// - use LIMIT 1	  $sql = "DELETE FROM ".self::$table_name;	  $sql .= " WHERE id=". $database->escape_value($this->id);	  $sql .= " LIMIT 1";	  $database->query($sql);	  return ($database->affected_rows() == 1) ? true : false;			// NB: After deleting, the instance of User still 		// exists, even though the database entry does not.		// This can be useful, as in:		//   echo $user->first_name . " was deleted";		// but, for example, we can't call $user->update() 		// after calling $user->delete().	}}?>